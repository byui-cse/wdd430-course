---
title: Web Development Review
description: This activity will review core concepts in Web Development that you need to succeed.
time: 1-2 hours
---

## Introduction

In the [syllabus](../../resources/syllabus) we find the following information:

**WDD 360** – It is expected that you have learned and mastered the information made available to you in WDD 360, and its prerequisite courses. If you feel rusty, the following is a more specific list of topics you would have been introduced to in those courses that will be important that you are comfortable with, and some sources to use for review before the course begins.

1. You should be very comfortable writing HTML and modern CSS. If you need a review you can read [MDN HTML Introduction](https://developer.mozilla.org/en-US/docs/Learn/Getting_started_with_the_web/HTML_basics) and [MDN CSS Introduction](https://developer.mozilla.org/en-US/docs/Learn/Getting_started_with_the_web/CSS_basics).
2. You should be comfortable with JavaScript fundamentals including variables, data types, functions, loops, and conditionals. If you need a review you can read [MDN JavaScript First Steps](https://developer.mozilla.org/en-US/docs/Learn/Getting_started_with_the_web/JavaScript_basics).
3. You should be comfortable creating websites with template based tools using a component based architecture.
4. Make sure you are comfortable with basic DOM manipulation with JavaScript. If you need a review you can read [MDN Manipulating Documents](https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Client-side_web_APIs/Manipulating_documents).
5. Make sure you are comfortable with basic event management with JavaScript. If you need a review you can read [MDN Introduction to Events](https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Building_blocks/Events).
6. You should also be comfortable starting up a NodeJS server and running a simple Express app. If you need a review you can read [Express.js](https://expressjs.com/en/starter/hello-world.html).

This course is challenging to write a review for because the sky is the limit on technology stacks that might show up. But this is a Web development course and so it is reasonable to assume that HTML, CSS, and Javascript will show up to some extent in each stack. We can also assume that there will be developer tooling involved as well to help us manage dependencies and other complexities.

This review then will focus on these things.

### Learning objectives

- Recall and practice core HTML semantics and accessibility techniques ✅
- Write and organize CSS using modern approaches (vanilla, SCSS, Tailwind) ✅
- Manipulate the DOM and use events to create interactive pages ✅
- Use Fetch/Promises and async/await safely, and handle errors ✅
- Start a simple toolchain (Node/Express), run a dev server, and understand package managers and bundlers ✅

To review all of that we will build a simple Tic Tac Toe app. It will be a two player game with the option to save games to a server


## **01** HTML

HTML is still the star of the show in web development since that is how content is delivered to browsers. More and more however the HTML is generated with the help of tools instead of being written by hand by a developer.

1. Writing by hand with help from tools like Emmet
2. Using a templating tool (ie Astro, 11ty)
3. Generated by AI
4. Server side generating HTML (with PHP, Ruby, Python, or NodeJS for example)
5. Client side rendering HTML (covered in the JavaScript section)

Even with the help that we can get from all of these tools, semantics are still important...in fact they are more important than ever. Many of these tools (especially AI) will benefit from good semantic HTML.

For this exercise (building the tic tac toe board) we will write most of the HTML by hand since it is fairly simple. We do however need to think about the best way to represent our board. CSS Grid seems like a natural fit for styling, which means that we should try and structure out HTML with a parent and 9 children. One for each cell of our board.

1. Create a new file: `review/client/index.html` and add the basis of a valid HTML page with some semantic structure: `header`, `main`, `nav`, `footer`
2. Add a title in the header to let users know what the page is about. Then build out the board. A `section` might be our bst option to represent our board, and then since we will be performing an action when we click on a cell, a simple `button` would work best.
3. Think through all of the UI elements we will need to really play this game. For example what if a user wants to play again? How will we let the user know when a game is over, and what the result was? Make sure to include these in your page.
>Even though we will eventually generate this board with Javascript, we should build out an example now that we can use to figure out the styling. That means we need 9 divs. [Emmet](https://emmet.io) could be helpful here. It is built into VS Code.
> 
>Try typing the following where you want the divs: `button.cell*9{X}` then hit `tab`. It should expand into the following:
>```html
><button class="cell">X</button>
><button class="cell">X</button>
><button class="cell">X</button>
><button class="cell">X</button>
><button class="cell">X</button>
><button class="cell">X</button>
><button class="cell">X</button>
><button class="cell">X</button>
><button class="cell">X</button>
>```
>
>You could even add the containing `section` if you wanted: `section#board.board>button.cell*9{X}`. This would create a section with a class and ID of `board` then add 9 buttons as children.


## **02** CSS

CSS is still responsible for the styling of web pages. But it shows up in many different ways.

1. Vanilla CSS (selectors, attributes, etc):
    In this use case CSS naming and architecture become very important. Conventions like [BEM](https://getbem.com) or [CUBE CSS](https://cube.fyi) are commonly used
2. CSS Preprocessors like SCSS
3. Scoped CSS using a component based framework:
    Many Frameworks will allow scoped CSS to be attached directly to a component to avoid naming problems with the CSS default of global scope.
4. Libraries such as Bootstrap:
    Bootstrap and other libraries were attempts to share solutions to common problems.
5. TailwindCSS:
    [Tailwind](https://tailwindcss.com) plays a similar role to Bootstrap, but follows a utility first approach.

Again for the purposes of this review we are going focus on CSS. Write the CSS necessary to style our simple page.

1. Start with the global styles you want: font, spacing, page content width, general layout.
2. Then move to the board. CSS Grid will be the natural tool to do the major layout for it. Make sure that the cells are big enough to easily hit with a finger or pointer.
3. Add the lines for our board. Typically a Tic Tac Toe board does not have a border on the outside edge. We can use some `nth-child` to accomplish this without having to brute force it by creating 9 individual rules

<Details summary="Solution">

Your solution does not have to match this. You probably styled yours differently to this. This is provided mainly to show the styling of the board borders.

Note that this solution also uses [CSS variables](https://developer.mozilla.org/en-US/docs/Web/CSS/Guides/Cascading_variables/Using_custom_properties) and native [CSS nesting](https://developer.mozilla.org/en-US/docs/Web/CSS/Guides/Nesting). Check those out if you are unfamiliar.

```css
:root {
  --cell-size: 3rem;
}

body {
  margin: 0;
  font-size: 1.2em;
  font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto,
    Oxygen, Ubuntu, Cantarell, "Open Sans", "Helvetica Neue", sans-serif;
  max-width: 600px;
  margin: auto;
}

button {
  padding: 0.5em;
  margin: 0.5em;
}

.board {
  display: grid;
  grid-template-columns: repeat(3, var(--cell-size));
  grid-template-rows: repeat(3, var(--cell-size));
  text-align: center;
  button {
    background-color: transparent;
    border: 0;
    border-radius: 0;
    padding: 0;
    margin: 0;
    font-size: 2.5rem;
  }
  /* start a child 2 and then skip three (2,5,8)...this will select the middle column */
  > button:nth-child(3n + 2) {
    border-left: 1px solid;
    border-right: 1px solid;
  }
  /* start on the 4th from the beginning (4,5,6,7,8,9) then start at 6 from the end (1,2,3,4,5,6) 
  the overlap (4,5,6) matches both conditions (middle row)  */
  > button:nth-child(n + 4):nth-child(-n + 6) {
    border-top: 1px solid;
    border-bottom: 1px solid;
  }
}

.history {
  display: flex;
  flex-wrap: wrap;
  gap: 1em;
}

```
</Details>


## **03** Javascript and the DOM

Javascript is still the language of the web. It is used to do everything from adding simple dynamic interactions to our pages, to generating most of the HTML for our site.

### DOM manipulation and events

The original purpose of Javascript was to allow developers to make their webpages dynamic. It's reach has moved beyond that, but a large percentage of Javascript written is still of this purpose.

When the browser requests an HTML file from a server, it downloads it then begins parsing though it. It downloads any `script` files and resolves any `link` requests for css, then it starts converting the HTML into code in it's memory. This code is called the Document Object Model, the DOM. For example if we had the following HTML:

```html
<html>
  <body>
    <h1>Hello World</h1>
    <p class="p1">This is a paragraph.This is a <a href="#">link</a> in a paragraph.</p>
    <img src="image.jpg" alt="An image">
  </body>
</html>
```

It would look like this in the DOM:

```text
Document
 └── html
     └── body
         ├── h1 ("Hello World")
         ├── p.p1 ("This is a paragraph.")
            ├── text ("This is a ")
            ├── a ("link")
            └── text (" in a paragraph.")
         └── img

```

Each element becomes a node in a tree. In order to make a change to the document structure, we must first find the right node in the tree. We gain access through the `document` object that the browser makes available to us.

The most common tool for finding the right node is with `document.querySelector` With this we can use any valid CSS selector to identify nodes in the DOM. So using the code provided earlier, if we wanted to make a change to the paragraph with the class `p1` we could do the following: `document.querySelector(".p1");`

Once we have it we can make changes. If we wanted to change the contents of that element we could use several methods:

```javascript
const theP = document.querySelector(".p1");
theP.textContent = "This is a new paragraph.";
theP.innerHTML = "This is <em>fancy</em> content";
theP.insertAdjacentHTML("afterbegin", "I got inserted at the beginning! ");
```
The `textContent` method replaces the contents of the element with the string we provide. The `innerHTML` method does the same, but it also parses the string as HTML. The `insertAdjacentHTML` method inserts the string at the specified location in the element.

We can also take advantage of the events that happen in the browser to make things happen. Take the following markup:

```html
<h2>Shopping list</h2>
<label for="item">New Item</label>
<input type="text" id="item" placeholder="Enter item">
<button id="addButton">Add Item</button>
<ul id="shopping-list"></ul>
```

Ideally when a user enters some text and clicks on the button it will be added to the list. We can use event listeners to make this happen.

```javascript
const addButton = document.querySelector("#addButton");
const shoppingList = document.querySelector("#shopping-list");
const itemInput = document.querySelector("#item");

function addHandler(e) {
    const item = itemInput.value.trim();
    if (item) {
        shoppingList.insertAdjacentHTML("beforeend", `<li>${item}</li>`);
        itemInput.value = '';
        itemInput.focus();
    }
}

addButton.addEventListener('click', addHandler);
// Also handle the Enter key for accessibility
itemInput.addEventListener('keydown', (e) => { if (e.key === 'Enter') addHandler(); });
```

### Fetch and Promises

When we need to retrieve information from an external source for our web page after it has loaded we use `Fetch`. There is a potential problem however. Requesting data from an external source can take a while. The Javascript engine is single threaded, which means it can only do one thing at a time. The browser handles this with Promises and the event loop.

You should remember from previous classes using the `async/await` syntax.  This is the most common way of telling the browser what it should do when the promise resolves...or finishes. Let's look at an example:

```javascript
const baseUrl = "https://pokeapi.co/api/v2/pokemon/";

async function getData(url) {
    console.log("getData Starts")
  const response = await fetch(baseUrl + url);
  console.log(response);
  const data = await response.json();
  console.log("inside getData", data);
  return data;
}

const data = getData("ditto");
console.log("after getData", data)
```

If you run this code what will you see in the console? Discuss with a neighbor, then look below.

import Details from '../../components/Details.astro'

<Details summary="Results" >

When you run this code you will see the following in the console:

1. getData Starts
2. after getData, undefined
3. inside getData, the data

Were you surprised by any part of this?

Async functions always return a promise. So even though we did `const data = await response.json();` we still have to `await` again when we run the function if we need the results of that function to be ready before we move on...which we did in this case.

</Details>

To get this to work we need to `await` the call to `getData`. In the past we could only do that inside of another `async` function, but we now have [top level await](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/await#top_level_await). But this only works in ESModules. So we can't take advantage of it here.

```javascript
const baseUrl = "https://pokeapi.co/api/v2/pokemon/";

async function getData(url) {
    console.log("getData Starts")
  const response = await fetch(baseUrl + url);
  console.log(response);
  const data = await response.json();
  console.log("inside getData", data);
  return data;
}

async function init() {
    const data = await getData("ditto");
    console.log("after getData", data)
}
init();

```

Now the code executes in the order we need it to.

1. getData Starts
2. inside getData, the data
3. after getData, the data


## **04** Build the App

After all of that review. Let's put it into practice by building out out Tic Tac Toe Application. Whenever starting a new programming task it is always taking a minute and thinking through the problem to come up with a list of steps. Make a list of your own, then compare to the one provide below.

<Details summary="List of Steps">
create a place to store our board and initialize it empty.
initialize the current player. (X or O)
get references to the DOM Nodes we will be interacting with: boardElement, resetButton, resultsElement
when the page loads, render current board
    create a template to build out the contents of our board based on the stored data.
    replace the contents of the board element with the results of that template
 watch for a click on the board.
    figure out which cell was clicked
    make sure it was blank
        add an X or O based on player
        render board
        check for a win/draw
            if an end condition is met display results
watch for click on reset button
    clear out board
    render empty board
    clear any results message
</Details>

Take a minute and think through what implementing the list might look like in code. Specifically what functions would make sense to create? Go ahead and stub out those functions. Again compare your work with the solution below. Your list does not need to match, but should encapsulate all of the same functionality.

<Details summary="Function stubs">
```js
// template function to create one cell
function cellTemplate(item) {}

// function to generate a complete board markup
function boardTemplate(board) {}

// function to render a board
function renderBoard(board) {
    //clear out previous board

    //use boardTemplate to generate the new board markup and insert it into the board element
}

// function to handle a click on the board
function boardClickedHandler(event) {
    // figure out which cell was clicked
    // make sure it was blank
    //     add an X or O based on player
    //     render board
    //     check for a win/draw
    //         if an end condition is met display results
}

// function to reset the game
function resetHandler() {}

// function to check to see if the game should end (win or tie)
function checkWin() {

}

// function to display the results of the game (win or tie)
function displayResults(winner) {}
```
</Details>

After comparing, write the rest of the code to complete the application.  After completing your version (or if you get stuck) There is a solution provided below.

>The trickiest part of this is figuring out if the game should end, and who has won. The game should end if one player gets three in a row, or if all the cells are full and there are no three in a rows.
>
>The tie case is easy...just check to see if any of the cells are still set to `""`
>
>For the other one approach would be to think through each win condition and compare the current board to each condition. This would not be a great solution for a game with a larger board...but with Tic Tac Toe it works very well.
>
>So if one player got their mark in cells `1,2,3`, that would be a win. Or `4,5,6`, or `7,8,9`. We would also want to identify the column and diagonal win patterns as well.
>
>```js
>const winConditions = [
>    [0, 1, 2], [3, 4, 5], [6, 7, 8], //rows
>    [0, 3, 6], [1, 4, 7], [2, 5, 8], //cols
>    [0, 4, 8], [2, 4, 6] //diagonals
>  ];
>```
>
>Then you can loop over the conditions and compare
>```js
>    const [a, b, c] = condition;
>    // Check if the first cell is not empty AND matches the other two
>    if (board[a] && board[a] === board[b] && board[a] === board[c])
>```

<Details summary="Part one Solution">
```js
let board = ["", "", "", "", "", "", "", "", ""];
let currentPlayer = "O";
const boardEl = document.querySelector("#board");
const resetButton = document.querySelector("#restart");
const resultsEl = document.querySelector(".results");

function cellTemplate(item, index) {
  return `<button id="cell-${index}" data-index="${index}">${item}</button>`;
}

function boardTemplate(board, container = false) {
  let template = "";
  // check to see if we need the <section> wrapper.
  if (container) {
    // add section element
    template = "<section class='board'>";
    template += board.map(cellTemplate).join("");
    template += "</section>";
  } else {
    template = board.map(cellTemplate).join("");
  }
  return template;
}

function renderBoard(board) {
  boardEl.innerHTML = "";
  boardEl.insertAdjacentHTML("afterbegin", boardTemplate(board));
}

function boardClickedHandler(ev) {
  const cell = ev.target;
  const cellIndex = cell.dataset.index;
  if (board[cellIndex]) {
    // there is something there...do nothing
    return;
  } else {
    // set the cell to the correct character
    board[cellIndex] = currentPlayer;
    // render the board so it show up
    renderBoard(board, boardEl);
    // change the current player
    currentPlayer = currentPlayer == "X" ? "O" : "X";
    // check for win/draw
    const winner = checkWin();
    // if we got anything back from the check function the game is over.
    if (winner) {
      displayResults(winner);
    }
  }
}

function resetHandler(ev) {
  board = ["", "", "", "", "", "", "", "", ""];
  resultsEl.innerHTML = "";
  renderBoard(board);
}

function checkWin() {
  const winConditions = [
    [0, 1, 2],
    [3, 4, 5],
    [6, 7, 8], //rows
    [0, 3, 6],
    [1, 4, 7],
    [2, 5, 8], //cols
    [0, 4, 8],
    [2, 4, 6] //diagonals
  ];
  for (let condition of winConditions) {
    const [a, b, c] = condition;

    // Check if the first cell is not empty AND matches the other two
    if (board[a] && board[a] === board[b] && board[a] === board[c]) {
      return board[a]; // Returns 'X' or 'O' as the winner
    }
  }

  // Check for a draw (if no cells are empty)
  if (!board.includes("")) {
    return "Draw";
  }

  return null; // Game is still going
}

function displayResults(winner) {
  if (winner == "Draw") {
    resultsEl.innerHTML = "Game is a Draw.";
  } else resultsEl.innerHTML = `Player ${winner} has won!`;
}
```
</Details>

## **05** Tooling

Review [Frontend workflow](../../resources/workflow-info-only)


## **06** Backend

To finish out our review, and the application we are going to add the ability for the user to save a game to a server. We will use a NodeJS/Express server for this.

1. Create a new directory: `review/server`
2. cd into the directory in the terminal (open terminal (`ctrl- ~` in VS Code), `cd server`)
3. Initialize a new project: `(p)npm init`
4. Install dependencies: `(p)npm install express cors`
5. Open the `package.json` file and add `"type": "module"` to allow us to use ES Modules in our code.
6. Add a script to make it easy to run our server: `"dev": "node --watch --env-file=.env src/server.js"
7. Create a `src/.env` file and add `PORT=3000` to that file.
8. Create a `src/index.js` file and open it. add the following to that file:
```js
const port = process.env.PORT
console.log(port)
```
9. Type `(p)npm run dev` in the terminal and make sure you see `3000` show up in the console.

We now have a simple node app running. To finish we need to do the following:

1. Import our dependencies: express, and cors
2. Initialize express
3. Create a variable to hold our saved games.
4. Use the cors middleware.
5. Use the JSON middleware
6. Create a route: `GET /boards`. This should return all the boards as JSON
7. Create a second route: `POST /boards`. This should expect a new board in the request body, if a board was sent, add it to the list of stored games.
8. Start up our Express app and listen on the specified port.


<Details summary="Solution (index.js)">
```js
import express from "express";
import cors from "cors";

const port = process.env.PORT;
const app = express();

const games = [];

// need to enable cors
app.use(cors());

app.use(express.json({ limit: "10kb" })); // To parse the incoming requests with JSON payloads

app.get("/boards", (req, res) => {
  res.json(games);
});

app.post("/boards", (req, res) => {
  console.log(req.body);
  games.push(req.body);
  res.json({ message: "Game Saved" });
});

app.listen(port, () => {
  console.log("Listening on port: 3000");
});

```

</Details>

>We just setup a simple Express server. This should all have felt like review. If there are parts of the solution code that are unclear...study those parts until you understand why each line was in the solution and what each line was for!

## **07** Wrapping up

The last step is to add the functionality to our client to allow saving. We need a few more steps:

1. Add a Save button to the UI, also add a new `section` to where we will show any saved games.
2. Add a listener to the save button to call a `saveHandler` function. 
3. Create `saveHandler`. In that function we will send a `POST` fetch request to our server (http://localhost:3000) with the current content of our `board` variable as the body of the request. Then we should render the history.
4. Create a function `renderHistory`. This function will make a `GET` fetch request to our server to retrieve any saved games. Then it should render them in the history element.
>We created a `boardTemplate` earlier. It would be nice to re-use that here, but there is a difference between the main board and these history boards. For the main board the `section` already existed in the markup, so our template only generated the `div`s.
5. Modify the `boardTemplate` function to allow a boolean to be passed in: `container=false` We default it to false so that it will still work the same for the main board. If it is true however we need to modify the function to wrap the divs in `<section class="board"></section>` 
6. Test to make sure everything works.

<Details summary="Final Solution (client)">
```js
let board = ["", "", "", "", "", "", "", "", ""];
let currentPlayer = "O";
const boardEl = document.querySelector("#board");
const historyEl = document.querySelector(".history");
const resetButton = document.querySelector("#restart");
const saveButton = document.querySelector("#save");
const resultsEl = document.querySelector(".results");

function cellTemplate(item, index) {
  return `<button id="cell-${index}" data-index="${index}">${item}</button>`;
}

function boardTemplate(board, container = false) {
  let template = "";
  // check to see if we need the <section> wrapper.
  if (container) {
    // add section element
    template = "<section class='board'>";
    template += board.map(cellTemplate).join("");
    template += "</section>";
  } else {
    template = board.map(cellTemplate).join("");
  }
  return template;
}

function renderBoard(board) {
  boardEl.innerHTML = "";
  boardEl.insertAdjacentHTML("afterbegin", boardTemplate(board));
}

function boardClickedHandler(ev) {
  const cell = ev.target;
  const cellIndex = cell.dataset.index;
  if (board[cellIndex]) {
    // there is something there...do nothing
    return;
  } else {
    // set the cell to the correct character
    board[cellIndex] = currentPlayer;
    // render the board so it show up
    renderBoard(board, boardEl);
    // change the current player
    currentPlayer = currentPlayer == "X" ? "O" : "X";
    // check for win/draw
    const winner = checkWin();
    // if we got anything back from the check function the game is over.
    if (winner) {
      displayResults(winner);
    }
  }
}

function resetHandler(ev) {
  board = ["", "", "", "", "", "", "", "", ""];
  resultsEl.innerHTML = "";
  renderBoard(board);
}

function checkWin() {
  const winConditions = [
    [0, 1, 2],
    [3, 4, 5],
    [6, 7, 8], //rows
    [0, 3, 6],
    [1, 4, 7],
    [2, 5, 8], //cols
    [0, 4, 8],
    [2, 4, 6] //diagonals
  ];
  for (let condition of winConditions) {
    const [a, b, c] = condition;

    // Check if the first cell is not empty AND matches the other two
    if (board[a] && board[a] === board[b] && board[a] === board[c]) {
      return board[a]; // Returns 'X' or 'O' as the winner
    }
  }

  // Check for a draw (if no cells are empty)
  if (!board.includes("")) {
    return "Draw";
  }

  return null; // Game is still going
}

function displayResults(winner) {
  if (winner == "Draw") {
    resultsEl.innerHTML = "Game is a Draw.";
  } else resultsEl.innerHTML = `Player ${winner} has won!`;
}

async function saveHandler() {
  const options = {
    method: "POST",
    headers: {
      "Content-Type": "application/json"
    },
    body: JSON.stringify(board)
  };
  const res = await fetch("http://localhost:3000/boards", options);
  if (res.ok) {
    console.log(await res.json());
    renderHistory();
  }
}

async function renderHistory() {
  // get saved games
  const res = await fetch("http://localhost:3000/boards");
  if (res.ok) {
    const data = await res.json();
    historyEl.innerHTML = "";
    // note boardTemplate does not just want a board...but also a boolean. That means we can't just use it a a callback for map. We need to wrap in in another anon function...
    const html = data.map((board) => boardTemplate(board, true));
    historyEl.insertAdjacentHTML("afterbegin", html.join(""));
  }
}

// set listeners
boardEl.addEventListener("click", boardClickedHandler);
resetButton.addEventListener("click", resetHandler);
saveButton.addEventListener("click", saveHandler);
// do initial render
renderBoard(board);
renderHistory();
```
</Details>

## **08** (Optional) Solution with a Framework

It is interesting to see how the solution changes if a frontend framework is used instead of vanilla Javascript. some of the code we wrote will become unnecessary because the framework will handle things like updating UI when state changes for example.

Here is a possible solution using the Svelte framework. Notice how the implementation changed in places because of the framework.

If you want to run this then do the following:

1. In the terminal make sure that you are in the `review` directory.
2. Type `(p)npm create vite@latest`  Type `svelte` for the project name, pick Svelte as the tool, Javascript, no on the rollup, and yes on installing the dependencies.
3. Open up `review/svelte/src/App.svelte` Replace the contents with the code below.
4. Create a file in `review/svelte/src/lib/Board.svelte` and copy the code below into that file.
5. Check in the browser to make sure everything is working.

<Details summary="Svelte Solution">
```js
<script>
// Board.svelte
  const { board, boardClickedHandler = () => {} } = $props();
  // we are sharing this with the main board which needs to be interactive, and the history boards which should not. One way to handle this is to pass in a function for the handler. If no function is passed an empty function is used
</script>

<section aria-label="board">
  {#each board as cell, index}
    <button onclick={boardClickedHandler} data-index={index}>{cell}</button>
  {/each}
</section>

<style>
  :root {
    --cell-size: 3rem;
  }
  section {
    display: grid;
    grid-template-columns: repeat(3, var(--cell-size));
    grid-template-rows: repeat(3, var(--cell-size));
    font-size: 2.5rem;
    text-align: center;
    /* start a child 2 and then skip three (2,5,8)...this will select the middle column */
    > button:nth-child(3n + 2) {
      border-left: 1px solid;
      border-right: 1px solid;
    }
    /* start on the 4th from the beginning (4,5,6,7,8,9) then start at 6 from the end (1,2,3,4,5,6) 
  the overlap (4,5,6) matches both conditions (middle row)  */
    > button:nth-child(n + 4):nth-child(-n + 6) {
      border-top: 1px solid;
      border-bottom: 1px solid;
    }
  }
  button {
    background-color: transparent;
    border: 0;
    border-radius: 0;
    padding: 0;
  }
</style>

```

```js
<script>
// App.svelte
  import Board from "./lib/Board.svelte";
  import { onMount } from "svelte";

 // these are all state variable because if any of them change we want the UI to update as well.
  let board = $state(["", "", "", "", "", "", "", "", ""]);
  let currentPlayer = $state("O");
  let results = $state("");
  let history = $state([]);

  function boardClickedHandler(ev) {
    const cell = ev.target;
    const cellIndex = cell.dataset.index;
    if (board[cellIndex]) {
      // there is something there...do nothing
      return;
    } else {
      // set the cell to the correct character
      board[cellIndex] = currentPlayer;
      // board re-renders automatically because we change a state variable: board
      
      // change the current player
      currentPlayer = currentPlayer == "X" ? "O" : "X";
      // check for win/draw
      const winner = checkWin();
      // if we got anything back from the check function the game is over.
      if (winner) {
        displayResults(winner);
      }
    }
  }

  function resetHandler(ev) {
    board = ["", "", "", "", "", "", "", "", ""];
    results = "";
  }

  function checkWin() {
    const winConditions = [
      [0, 1, 2],
      [3, 4, 5],
      [6, 7, 8], //rows
      [0, 3, 6],
      [1, 4, 7],
      [2, 5, 8], //cols
      [0, 4, 8],
      [2, 4, 6] //diagonals
    ];
    for (let condition of winConditions) {
      const [a, b, c] = condition;

      // Check if the first cell is not empty AND matches the other two
      if (board[a] && board[a] === board[b] && board[a] === board[c]) {
        return board[a]; // Returns 'X' or 'O' as the winner
      }
    }

    // Check for a draw (if no cells are empty)
    if (!board.includes("")) {
      return "Draw";
    }

    return null; // Game is still going
  }

  function displayResults(winner) {
    if (winner == "Draw") {
      results = "Game is a Draw.";
    } else results = `Player ${winner} has won!`;
  }

  async function saveHandler() {
    const options = {
      method: "POST",
      headers: {
        "Content-Type": "application/json"
      },
      body: JSON.stringify(board)
    };
    const res = await fetch("http://localhost:3000/boards", options);
    if (res.ok) {
      console.log(await res.json());
      renderHistory();
    }
  }

  async function renderHistory() {
    // get saved games
    const res = await fetch("http://localhost:3000/boards");
    if (res.ok) {
      history = await res.json();
    }
  }

  onMount(() => {
    // get history
    renderHistory();
  });
</script>

<main>
  <h1>Tic Tac Toe</h1>

  <div class="card">
  <p>Currently {currentPlayer}'s turn</p>
    <Board {board} {boardClickedHandler} />
  </div>

  <section class="controls">
    <button id="restart" onclick={resetHandler}>Restart</button>
    <button id="save" onclick={saveHandler}>Save</button>
  </section>
  {#if results}
    <p class="results">{results}</p>
  {/if}
  <h2>History</h2>
  <section class="history">
    {#each history as game}
      <Board board={game} />
    {/each}
  </section>
</main>

<style>
  .history {
    display: flex;
    flex-wrap: wrap;
    gap: 1em;
  }
</style>

```

</Details>


